\documentclass[]{article}

\usepackage{datetime}

\newcommand{\spec}[1]{\textit{#1}\par\noindent}

% Uncomment the following to hide spec:
% \renewcommand{\spec}[1]{}

\newdate{date}{9}{12}{2016}
\date{\displaydate{date}}

\title{WACC Compiler Report}
\author{
	Anantachok Duangsarot \\
	\and
	James Knight \\
	\and
	Jaspreet Randhawa \\
	\and
	Max Smith \\
}

\begin{document}

\maketitle

\section{The Product}
\spec{An analysis and critical evaluation of the quality of the WACC compiler you have built. You should consider both whether it meets the functional specification and whether you judge that it forms a sound basis for future development. You may wish to address performance issues.}
Firstly, the frontend of our compiler turned out very well. The lexer and parser represent the specification perfectly, with the ANTLR framework performing the bulk of the work for the lexical and syntactic analysis. The semantic analysis was more challenging, with ANTLR only providing a groundwork through the visitor pattern. In the end though, we successfully managed to meet the specification, passing all of the example tests provided. This frontend gave us a strong building block for starting the backend, as we knew that we wouldn't have to go back to fix it and all of our efforts could be focused on the backend.

The backend was a much more challenging task. Some early decisions of the backend's design made things more difficult as time went on. Overall, we managed to get it to a point in which it passed most of the specification, however there are still some things that the compiler fails to do, for example treating strings as mutable char arrays.

We made a decision to have the compiler generate functional code over optimised code so that we had more time to complete the specification, however this results in some ugly code generated. For example, instead of moving the stack pointer by the number of variables needed every time we enter a new scope, we instead move the stack pointer every time a variable is declared, vastly increasing the number of SUB commands in a program with many variables.

Also, the compiler doesn't check whether a string has already been used previously in the program. This means, if a program uses the same string multiple times, it will appear at the head of the file multiple times. This can make the code difficult to read.

The difficulty of future development is mixed. Whilst we think it's easy to make certain improvements, such as extending the language specification in many ways (some of which we have done in our extension), other improvments such as some compiler optimisations are more difficult. The way the backend is designed, instructions know very little about the program state other than their own children in the tree. This makes it hard to make changes that rely on knowing things like the number of registers that are going to be used or when variables are used, which makes it hard to make many of the optimisations.

\section{The Project Management}
\spec{An analysis of the organisation of your group and your use of project management tools (such as Git). You should describe how your group was structured, how you coordinated your work and detail any tools that helped/hindered your progress. You should also discuss what went well and what you would do differently if you were to do the lab again.}
We organised our project using Git. By using the Git branching tools, we managed to easily distinguish between functioning and non-functioning code, and avoid merge conflicts. Firstly, we made sure to reserve the master branch for functioning code. By making sure that only code that compiles and runs successfully is on the master branch, we always knew which version we had to run large-scale testing on.

Non-tested code was put on the development branch. We tried to make sure that the code here would always compile, but we were less strict about that on this branch. Once we were confident that the code on development worked properly, we would merge it into master. Each individual group member would develop on their own branch, then merge onto the development branch once they were done. This allowed us to avoid merge conflicts, as there was never more than one person working on the same branch at the same time. 

We worked together to build the general structure of the frontend and backend so that we all knew how the program would function, then divided tasks between each of us. Whilst a lot of the code was written individually, we also did some pair programming as we found that having a second pair of eyes was useful.

We wrote a test suite in ruby, designed to mimic the test suite on LabTS. This meant we could test code quicker than using LabTS and allowed us to do testing without having to merge bad code onto the master branch. This turned out to be incredibly useful, and had added benefits such as being able to test only specific categories of tests to save time. This improved our productivity greatly as their was much less downtime from waiting for LabTS to test code.

However, there are a few things that we would change if we were to do the lab again. Whilst we are very happy with the frontend, we think the backend could do with some improvement. Firstly, we would start on the backend earlier, as we were pressed for time which stopped us from doing as much as we had wanted. Also, we would spend some more time planning out the design of the backend and weighing out the pros and cons of different design patterns. The way we ended up doing it, we stumbled upon a lot of issues which could be fixed by changing the design, but at that point we were too far in to rewrite the program completely.

\section{The Design Choices}
\spec{An analysis of the design choices that you made during the WACC lab. You should discuss the design patterns you used when designing your code and why you chose to use them.}
We used a variety of different patterns whilst designing the WACC lab. Firstly, we use a listener pattern for the error listener. This is an object that subscribes to the syntax parser. Whenever the parser throws an error, the error listener is notified, so it can handle that error by printing a useful error message for the user.

Next, there is the most important one - the visitor pattern. The ANTLR tool that we used generates a default visitor pattern for traversing the Abstract Syntax Tree (AST). As each node of the tree contains different tokens, each node needs to be a different class. So that we can access the contents of these nodes and perform different operations on them, we need to use a visitor pattern, which provides a separate visit function for each of these different classes. We use this in our frontend, where we perform semantic analysis.

We use a second visitor pattern in the backend, where we traverse the AST and generate the corresponding instructions. We do this by building an instruction tree - each node of the AST has it's own instruction class which may take a number of child instructions. Each instruction has a toAssembly method which takes a PrintStream and outputs the assembly for its instruction, calling its children's toAssembly methods in the process. By building the instruction tree as we walk the AST, we allow each node to know about the program state and instructions of its children. Then, after the whole tree is generated, we can call the toAssembly method of the head of the tree to print out the whole program.

Control flow instructions use branching to navigate the program. This requires us to generate labels to denote where to branch to, but these labels need to be unique so that the assembly is valid. We do this using a LabelMaker class which implements the singleton pattern. This labelmaker contains a map of instructions to label names, allowing it to generate a unique label name for that instruction, and then retrieve that label name later. By having it as a singleton class, there can only ever be one LabelMaker generated, meaning there is only a single map. This stops any errors where two instructions generate two different LabelMakers, then end up generating the same label. As a side effect, this allows for static access to the LabelMaker, meaning it does not have to be passed to the instructions.

\section{Beyond the Specification}
\spec{An evaluation of your extensions to your WACC compiler. You should describe all of the language extensions, optimisations or other aspects that you have added to your compiler, including how these features can be accessed or viewed. You should also briefly discuss what future extensions you would like to add to your WACC compiler if you had more time.}
...
\subsection{Max}



\subsection{Anant}



\subsection{Jas}



\subsection{James}



\end{document}